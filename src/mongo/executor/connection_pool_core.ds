{{
#include <memory>

#include "mongo/stdx/chrono.h"
#include "mongo/stdx/functional.h"
#include "mongo/util/net/hostandport.h"
#include "mongo/util/time_support.h"
#include "mongo/executor/connection_pool.h"

namespace std {
  template <> struct hash<mongo::Date_t> {
    typedef mongo::Date_t argument_type;
    typedef std::size_t result_type;
    result_type operator()(argument_type const& x) const noexcept {
      return static_cast<result_type>(x.toMillisSinceEpoch());
    }
  };
}

}}

ConnectionPoolCore:
    type HostAndPort = Native "mongo::HostAndPort"
    type Timestamp = Native "mongo::Date_t"
    type Timespan  = Native "mongo::Milliseconds"
    type Callback = Native "mongo::executor::ConnectionPool::GetConnectionCallback*"
    type ConnState = enum { READY, PROCESSING, CHECKED_OUT }
    type ConnInterface = Native "mongo::executor::ConnectionPool::ConnectionInterface*"

    type Connection = {
        conn_state        : ConnState,
        conn_host         : HostAndPort,
        conn_iface        : ConnInterface,
        conn_next_refresh : Timestamp,
        conn_returned     : Timestamp,
        conn_last_used    : Int,
        conn_dropped      : Bool
    }

    type Request = {
        rq_callback   : Callback,
        rq_expiration : Timestamp,
        rq_host       : HostAndPort
    }

    extern eternity() : Timestamp = "mongo::Date_t::max()"
    extern after(t : Timestamp, span : Timespan) : Timestamp = "{t} + {span}"
    extern nullConn() : ConnInterface = "nullptr"
    extern nullReq() : Callback = "nullptr"

    // options (immutable)
    state minConnections     : Int
    state maxConnections     : Int
    state maxConnecting      : Int
    state refreshTimeout     : Timespan
    state refreshRequirement : Timespan
    state hostTimeout        : Timespan

    // state
    state conns          : Set<Connection>
    state reqs           : Set<Request>
    state retId          : Int

    invariant unique [ c.conn_iface | c <- conns ];
    invariant all [ c.conn_last_used < retId | c <- conns, c.conn_state == READY ];
    invariant unique [ r.rq_callback | r <- reqs ];

    // ------------------------------------------------------------ STATS

    query allHosts()
        distinct [ c.conn_host | c <- conns ]

    query connsForHost(p : HostAndPort)
        [ c.conn_iface | c <- conns, c.conn_host == p ]

    private query enumerateReadyConns(p : HostAndPort)
        [ c | c <- conns, c.conn_host == p and c.conn_state == READY ]

    query inUseConnections(p : HostAndPort)
        len [ c | c <- conns, c.conn_host == p and c.conn_state == CHECKED_OUT ]

    query availableConnections(p : HostAndPort)
        len enumerateReadyConns(p)

    query refreshingConnections(p : HostAndPort)
        len [ c | c <- conns, c.conn_host == p and c.conn_state == PROCESSING ]

    query openConnections(p : HostAndPort)
        inUseConnections(p) + availableConnections(p) + refreshingConnections(p)

    private query reqDataForHost(p : HostAndPort)
        [ r | r <- reqs, r.rq_host == p ]

    query reqsForHost(p : HostAndPort)
        [ r.rq_callback | r <- reqDataForHost(p) ]

    private query numReqs(p : HostAndPort)
        len reqDataForHost(p)

    // ------------------------------------------------------------ CORE

    query getRefreshTimeout()
        refreshTimeout

    query needsMoreConnections(p : HostAndPort)
        // Our goal is to keep the following constraints satisfied (more
        // important ones first):
        //   - #refreshing <= maxConnecting AND
        //   - #conns <= max AND
        //   - #conns >= min AND
        //   - (#avail + #proc) = #req
        // Thus, we need more connections if the first two would remain
        // satisfied after adding a connection (i.e. < instead of <=) and
        // either #conns falls short of min or we don't have enough connections
        // to satisfy the requests.
        (refreshingConnections(p) < maxConnecting) and
        (openConnections(p) < maxConnections) and
        (openConnections(p) < minConnections or
            availableConnections(p) + refreshingConnections(p) < numReqs(p))

    private query hasReq(p : HostAndPort)
        exists reqDataForHost(p)

    query nextReq(p : HostAndPort)
        // The next request to expire
        hasReq(p) ?
            (argmin { req -> req.rq_expiration } reqDataForHost(p)).rq_callback :
            nullReq()

    query mruConn(p : HostAndPort)
        exists enumerateReadyConns(p) ?
            (argmax { c -> c.conn_last_used } [ c | c <- enumerateReadyConns(p) ]).conn_iface :
            nullConn()

    private query someConnIsCheckedOut(p : HostAndPort)
        exists [ c | c <- conns, c.conn_host == p and c.conn_state == CHECKED_OUT ]

    private query isRunning(p : HostAndPort)
        hasReq(p) or someConnIsCheckedOut(p)

    private query hasInterface(i : ConnInterface)
        exists [ c | c <- conns, c.conn_iface == i ]

    private query handleForInterface(i : ConnInterface)
        assume hasInterface(i);
        the [ c | c <- conns, c.conn_iface == i ]

    query shouldKeepConnection(i : ConnInterface, now : Timestamp)
        // Do we want keep this ready connection around?
        assume hasInterface(i);
        assume handleForInterface(i).conn_state == READY;
        // YES, if it has been used very recently (NOTE: I got this wrong at first)
            (after(handleForInterface(i).conn_returned, refreshRequirement) > now) or
        // YES, if we need to keep minConnections constraint satisfied
            (openConnections(handleForInterface(i).conn_host) <= minConnections) or
        // YES, if we have requests to serve
            (availableConnections(handleForInterface(i).conn_host) + refreshingConnections(handleForInterface(i).conn_host) < numReqs(handleForInterface(i).conn_host))
        // and of course, NO otherwise.

    query connState(i : ConnInterface)
        assume hasInterface(i);
        handleForInterface(i).conn_state

    query connHostAndPort(i : ConnInterface)
        assume hasInterface(i);
        handleForInterface(i).conn_host

    query wasDropped(i : ConnInterface)
        assume hasInterface(i);
        handleForInterface(i).conn_dropped

    private query lastActivity(p : HostAndPort)
        // When was the last time a connection got returned?
        assume not isRunning(p);
        max [ c.conn_returned |
            c <- conns, c.conn_host == p and
            c.conn_state != CHECKED_OUT ]

    private query hostExpiration(p : HostAndPort)
        // When should we determine that we can close all the open connections
        // to a given host/port?
        assume not isRunning(p);
        after(lastActivity(p), hostTimeout)

    private query idleHosts()
        [p | p <- allHosts(), not isRunning(p)]

    query hasEvent()
        exists reqs or exists [ c | c <- conns, c.conn_state == READY ]

    query nextEvent()
        assume hasEvent();
        min ([ r.rq_expiration     | r <- reqs ] +
             [ c.conn_next_refresh | c <- conns, c.conn_state == READY ] +
             [ hostExpiration(p)   | p <- idleHosts() ])

    query nextRequestToExpire()
        assume exists reqs;
        (argmin { r -> r.rq_expiration } reqs).rq_callback

    query hasExpiredRequest(now : Timestamp)
        exists [r | r <- reqs, r.rq_expiration <= now]

    private query readyConns()
        [ c | c <- conns, c.conn_state == READY ]

    query nextConnectionToRefresh()
        assume exists readyConns();
        (argmin { c -> c.conn_next_refresh } readyConns()).conn_iface

    query hasConnectionToRefresh(now : Timestamp)
        exists [c | c <- readyConns(), c.conn_next_refresh <= now]

    query hasExpiredHost(now : Timestamp)
        exists [ h | h <- idleHosts(), hostExpiration(h) <= now]

    query nextHostToExpire(now : Timestamp)
        assume hasExpiredHost(now);
        argmin { p -> hostExpiration(p) } idleHosts()

    // ------------------------------------------------------------ UPDATES

    private query markedReady(c : Connection, now : Timestamp, lastUsed : Timestamp)
        {   conn_state        : READY,
            conn_host         : c.conn_host,
            conn_iface        : c.conn_iface,
            conn_next_refresh : after(lastUsed, refreshRequirement),
            conn_returned     : now,
            conn_last_used    : retId,
            conn_dropped      : c.conn_dropped}

    private query markedProc(c : Connection)
        {   conn_state        : PROCESSING,
            conn_host         : c.conn_host,
            conn_iface        : c.conn_iface,
            conn_next_refresh : c.conn_next_refresh,
            conn_returned     : c.conn_returned,
            conn_last_used    : c.conn_last_used,
            conn_dropped      : c.conn_dropped}

    private query markedCo(c : Connection)
        {   conn_state        : CHECKED_OUT,
            conn_host         : c.conn_host,
            conn_iface        : c.conn_iface,
            conn_next_refresh : c.conn_next_refresh,
            conn_returned     : c.conn_returned,
            conn_last_used    : c.conn_last_used,
            conn_dropped      : c.conn_dropped}

    private query markedDropped(c : Connection)
        {   conn_state        : c.conn_state,
            conn_host         : c.conn_host,
            conn_iface        : c.conn_iface,
            conn_next_refresh : c.conn_next_refresh,
            conn_returned     : c.conn_returned,
            conn_last_used    : c.conn_last_used,
            conn_dropped      : true}

    op addReq(expiration : Timestamp, host : HostAndPort, callback : Callback)
        assume not exists [ r | r <- reqs, r.rq_callback == callback ];
        reqs.add({
            rq_callback   : callback,
            rq_expiration : expiration,
            rq_host       : host});

    op rmReq(id : Callback)
        assume   exists [ r | r <- reqs, r.rq_callback == id ];
        reqs.remove(the [ r | r <- reqs, r.rq_callback == id ]);

    op addConn(iface : ConnInterface, host : HostAndPort)
        assume not hasInterface(iface);
        conns.add({
            conn_state        : PROCESSING,
            conn_host         : host,
            conn_iface        : iface,
            conn_next_refresh : eternity(),
            conn_returned     : eternity(),
            conn_last_used    : 0,
            conn_dropped      : false});

    op rmConn(iface : ConnInterface)
        assume hasInterface(iface);
        conns.remove(handleForInterface(iface));

    op markDropped(i : ConnInterface)
        assume hasInterface(i);
        assume handleForInterface(i).conn_state == CHECKED_OUT;
        assume not handleForInterface(i).conn_dropped;
        conns = [ c.conn_iface == i ? markedDropped(c) : c | c <- conns ];

    op requestGranted(req : Callback, i : ConnInterface)
        assume hasInterface(i);
        assume handleForInterface(i).conn_state == READY;
        assume exists [ r | r <- reqs, r.rq_callback == req ];
        reqs.remove(the [ r | r <- reqs, r.rq_callback == req ]);
        conns = [ c.conn_iface == i ? markedCo(c) : c | c <- conns ];

    op markProcessing(i : ConnInterface)
        assume hasInterface(i);
        assume handleForInterface(i).conn_state == READY;
        conns = [ c.conn_iface == i ? markedProc(c) : c | c <- conns ];

    op markReady(
            i        : ConnInterface,
            now      : Timestamp,
            lastUsed : Timestamp)
        assume hasInterface(i);
        assume handleForInterface(i).conn_state != READY;
        conns = [ c.conn_iface == i ? markedReady(c, now, lastUsed) : c | c <- conns ];
        retId = retId + 1;
