{{
#include <memory>

#include "mongo/stdx/chrono.h"
#include "mongo/stdx/functional.h"
#include "mongo/util/net/hostandport.h"
#include "mongo/util/time_support.h"
#include "mongo/executor/connection_pool.h"

namespace std {
  template <> struct hash<mongo::Date_t> {
    typedef mongo::Date_t argument_type;
    typedef std::size_t result_type;
    result_type operator()(argument_type const& x) const noexcept {
      return static_cast<result_type>(x.toMillisSinceEpoch());
    }
  };
}

}}

ConnectionPoolCore:
    type HostAndPort = Native "mongo::HostAndPort"
    type Timestamp = Native "mongo::Date_t"
    type Timespan  = Native "mongo::Milliseconds"
    type Callback = Native "std::unique_ptr<mongo::executor::ConnectionPool::GetConnectionCallback>"
    type ConnState = enum { READY, PROCESSING, CHECKED_OUT }
    type ConnInterface = Native "mongo::executor::ConnectionPool::ConnectionInterface*"

    handletype Connection = {
        conn_state        : ConnState,
        conn_host         : HostAndPort,
        conn_iface        : ConnInterface,
        conn_next_refresh : Timestamp,
        conn_returned     : Timestamp,
        conn_last_used    : Int,
        conn_dropped      : Bool
    }

    handletype Request = {
        rq_expiration : Timestamp,
        rq_host       : HostAndPort,
        rq_callback   : Callback
    }

    extern eternity() : Timestamp = "mongo::Date_t::max()"
    extern after(t : Timestamp, span : Timespan) : Timestamp = "{t} + {span}"

    // options (immutable)
    state minConnections     : Int
    state maxConnections     : Int
    state maxConnecting      : Int
    state refreshTimeout     : Timespan
    state refreshRequirement : Timespan
    state hostTimeout        : Timespan

    // state
    state conns          : Set<Connection>
    state reqs           : Set<Request>
    state retId          : Int

    invariant unique [ c.val.conn_iface | c <- conns ];

    // ------------------------------------------------------------ STATS

    query allHosts()
        distinct [ c.val.conn_host | c <- conns ]

    query connsForHost(p : HostAndPort)
        [ c | c <- conns, c.val.conn_host == p ]

    private query enumerateReadyConns(p : HostAndPort)
        [ c | c <- conns, c.val.conn_host == p and c.val.conn_state == READY ]

    query inUseConnections(p : HostAndPort)
        len [ c | c <- conns, c.val.conn_host == p and c.val.conn_state == CHECKED_OUT ]

    query availableConnections(p : HostAndPort)
        len enumerateReadyConns(p)

    query refreshingConnections(p : HostAndPort)
        len [ c | c <- conns, c.val.conn_host == p and c.val.conn_state == PROCESSING ]

    query openConnections(p : HostAndPort)
        inUseConnections(p) + availableConnections(p) + refreshingConnections(p)

    query reqsForHost(p : HostAndPort)
        [ r | r <- reqs, r.val.rq_host == p ]

    private query numReqs(p : HostAndPort)
        len reqsForHost(p)

    // ------------------------------------------------------------ CORE

    query getRefreshRequirement()
        refreshRequirement
    query getRefreshTimeout()
        refreshTimeout

    query needsMoreConnections(p : HostAndPort)
        // Our goal is to keep the following constraints satisfied (more
        // important ones first):
        //   - #refreshing <= maxConnecting AND
        //   - #conns <= max AND
        //   - #conns >= min AND
        //   - (#avail + #proc) = #req
        // Thus, we need more connections if the first two would remain
        // satisfied after adding a connection (i.e. < instead of <=) and
        // either #conns falls short of min or we don't have enough connections
        // to satisfy the requests.
        (refreshingConnections(p) < maxConnecting) and
        (openConnections(p) < maxConnections) and
        (openConnections(p) < minConnections or
            availableConnections(p) + refreshingConnections(p) < numReqs(p))

    query shouldKeepConnection(c : Connection, now : Timestamp)
        // Do we want keep this ready connection around?
        assume c.val.conn_state == READY;
        // YES, if it has been used very recently (NOTE: I got this wrong at first)
            (after(c.val.conn_returned, refreshRequirement) > now) or
        // YES, if we need to keep minConnections constraint satisfied
            (openConnections(c.val.conn_host) <= minConnections) or
        // YES, if we have requests to serve
            (availableConnections(c.val.conn_host) + refreshingConnections(c.val.conn_host) < numReqs(c.val.conn_host))
        // and of course, NO otherwise.

    query nextReq(p : HostAndPort)
        // The next request to expire
        argmin { req -> req.val.rq_expiration } reqsForHost(p)

    private query hasReq(p : HostAndPort)
        exists reqsForHost(p)

    query mruConn(p : HostAndPort)
        argmax { c -> c.val.conn_last_used } [ c |
            c <- conns,
            c.val.conn_host == p,
            c.val.conn_state == READY ]

    private query someConnIsCheckedOut(p : HostAndPort)
        exists [ c | c <- conns, c.val.conn_host == p and c.val.conn_state == CHECKED_OUT ]

    private query isRunning(p : HostAndPort)
        hasReq(p) or someConnIsCheckedOut(p)

    query handleForInterface(i : ConnInterface)
        the [ c | c <- conns, c.val.conn_iface == i ]

    private query lastActivity(p : HostAndPort)
        // When was the last time a connection got returned?
        assume not isRunning(p);
        max [ c.val.conn_returned |
            c <- conns, c.val.conn_host == p and
            c.val.conn_state != CHECKED_OUT ]

    private query hostExpiration(p : HostAndPort)
        // When should we determine that we can close all the open connections
        // to a given host/port?
        isRunning(p) ? eternity() : after(lastActivity(p), hostTimeout)

    private query allKnownHosts()
        [ c.val.conn_host | c <- conns ] + [ r.val.rq_host | r <- reqs ]

    query hasEvent()
        exists reqs or exists [ c | c <- conns, c.val.conn_state == READY ]

    query nextEvent()
        assume hasEvent();
        min ([ r.val.rq_expiration     | r <- reqs ] +
             [ c.val.conn_next_refresh | c <- conns, c.val.conn_state == READY ] +
             [ hostExpiration(p)       | p <- allKnownHosts() ])

    query expiredRequests(now : Timestamp)
        [ r | r <- reqs, r.val.rq_expiration <= now ]

    query connectionsToRefresh(now : Timestamp)
        [ c | c <- conns,
            c.val.conn_state == READY and
            c.val.conn_next_refresh <= now ]

    query expiredHosts(now : Timestamp)
        [ p | p <- allKnownHosts(),
            not isRunning(p) and
            hostExpiration(p) <= now ]

    // ------------------------------------------------------------ UPDATES

    op addReq(r : Request)
        assume not (r in reqs);
        reqs.add(r);

    op rmReq(r : Request)
        assume r in reqs;
        reqs.remove(r);

    op addConn(c : Connection)
        assume not (c.val.conn_iface in [ cc.val.conn_iface | cc <- conns ]);
        assume not (c in conns);
        conns.add(c);

    op rmConn(c : Connection)
        assume c in conns;
        conns.remove(c);

    op markDropped(c : Connection)
        assume c.val.conn_state == CHECKED_OUT;
        assume c in conns;
        c.val.conn_dropped = true;

    op requestGranted(r : Request, c : Connection)
        assume r in reqs;
        assume c in conns;
        assume c.val.conn_state == READY;
        reqs.remove(r);
        c.val.conn_state = CHECKED_OUT;

    op changeState(
            c        : Connection,
            newstate : ConnState,
            now      : Timestamp,
            lastUsed : Timestamp,
            rt       : Timespan)
        assume rt == refreshRequirement; // Oops! Cozy bug requires this to be an arg.
        assume c in conns;
        c.val.conn_state = newstate;
        if (newstate == READY) {
            // this is now the most-recently-used connection
            c.val.conn_next_refresh = after(lastUsed, rt);
            c.val.conn_returned = now;
            c.val.conn_last_used = retId;
            retId = retId + 1;
        }
